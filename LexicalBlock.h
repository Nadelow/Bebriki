#pragma once
#include <iostream>
#include "LexBase.h"
#include <fstream>
#include <algorithm>
#include <string>
#include <Windows.h>
#include <sstream>
#include <vector>
#include <stack>
#include <list>

enum SymbolicTokenClass { Alpha, Digit, AR_OP, 
    Bool, Dot, Left_bracket, 
    Right_braket, Space, EndOfString, 
    EndOfFile, Exception, END, 
    FOR, GOSUB, GOTO, 
    IF, LET, NEXT, 
    REM, RETURN, STEP, TO };
enum States { A1, A2, A3, B1, C1, C2, D1, D2, D3, D4, D5, D6, E1, E2, F1, F2, F3, G1, H1, Stop };

struct LexemToken
{
    SymbolicTokenClass token_class = END;   // тип лексемы
    std::string reg_data;                   // данные в регистре
    int number_reg = 0;                     // регистр числа
    std::string relat_reg;                  // регистр отношения
    std::string variable_reg;               // регистр переменной
    int detect_reg = 0;                     // регистр обнаружения
    std::string token_reg;                  // регистр лексемы
    int reg_str = 1;                        // номер строки

    void clear()
    {
        number_reg = 0;
        reg_data.clear();
        relat_reg.clear();
        variable_reg.clear();
        detect_reg = 0;
        token_reg.clear();
    }
};

class LexicalBlock :
    public LexBase
{
public:
    LexicalBlock();
    LexicalBlock(const LexicalBlock& lexer) = delete;
    LexicalBlock(const LexicalBlock&& lexer) = delete;

    /*
    * @brief разбивает программу в filename на лексемы и возвращает вектор с ними
    * @param filename: имя файла
    * @return m_lexems: вектор лексем
    */
    std::vector<Token> Run(std::string filename);
private:
    /*
    * @brief определяет тип лексемы по с
    * @param c: символ
    * @return соответсвующий токен
    */
    SymbolicTokenClass identification(int c);

    /*
    * @brief проверяет, является ли лексема ключевым словом, если да, то добавляет её в вектор лексем
    * @param m_line: строка
    * @param m_lexem: лексема
    * @return true/false
    */
    bool Get_lexem(int m_line, std::string m_lexem);

    //Процедуры автомата

    /*
    * состояние выполняющее переход
    */
    int s_A1();

    /*
    * состояние выполняющее процедуру DA1D
    */
    int s_A1b();

    /*
    * состояние создающее лексему
    */
    int s_A1a();

    /*
    * состояние выполняющее процедуру DA2D
    */
    int s_A1c();

    /*
    * состояние выполняющее процедуру DA3D
    */
    int s_A1d();

    /*
    * состояние выполняющее процедуру DA1E
    */
    int s_A1e();

    /*
    * состояние выполняющее очистку лексемы
    */
    int s_A2();

    /*
    * состояние выполняющее процедуру DA1D
    */
    int s_A2c();

    /*
    * состояние выполняющее создание лексемы
    */
    int s_A2g();

    /*
    * состояние выполняющее загрузку арифметической операции в регистр класса
    */
    int s_A2a();

    /*
    * состояние выполняющее обработку лексемы в конце строки
    */
    int s_A2b();

    /*
    * состояние выполняющее DA2D
    */
    int s_A2d();

    /*
    * состояние выполняющее DA3D
    */
    int s_A2e();

    /*
    * состояние выполняющее DA1E
    */
    int s_A2f();

    /*
    * состояние выполняющее DA1E
    */
    int s_A2j();

    /*
    * состояние выполняющее создание лексемы
    */
    int s_A2k();

    /*
    * состояние выполняющее  загрузку левой скобки в регистр класса и создает лексему
    */
    int s_A2h();

    /*
    * состояние выполняющее DA1D
    */
    int s_A2l();

    /*
    * состояние выполняющее DA2D
    */
    int s_A2m();

    /*
    * состояние выполняющее DA3D
    */
    int s_A2n();

    /*
    * состояние выполняющее обработку ошибки если знак на вершине автомата не =
    */
    int s_A2o();

    /*
    * состояние выполняющее если регистр отношения и регистр значения через таблицу дали 0 => ошибка иначе полученное число добавляет в регистр отношения
    */
    int s_A2p();

    /*
    * состояние выполняющее загрузку конца в регистр класса
    */
    int s_A2q();

    /*
    * состояние выполняющее загрузку если в регистр класса
    */
    int s_A2r();

    /*
    * состояние выполняющее загрузку возврат в регистр класса
    */
    int s_A2s();
    ///////////////////////////////////////
    /*
    * состояние выполняющее обработку '<'
    */
    int s_A2t();

    /*
    * состояние выполняющее обработку '>'
    */
    int s_A2u();

    /*
    * состояние выполняещее обработку метки
    */
    int s_A3a();

    /*
    * состояние выполняющее переход по символу
    */
    int s_A3();

    /*
    * состояние выполняющее общую часть обработки '<' и '>'
    */

    int s_A3d();

    /*
    * состояние выполняющее создание лексемы
    */
    int s_A3c();

    /*
    * состояние выполняющее обработку '+'
    */
    int s_A3b();

    /*
    * состояние выполняющее ДА2Д в регистр класса
    */
    int s_A3e();

    /*
    * состояние выполняющее обработку '='
    */
    int s_A3f();

    /*
    * состояние выполняющее ДА1Е в регистр класса
    */
    int s_A3g();

    /*
    * состояние выполняющее ДА3Д в регистр класса
    */
    int s_B1c();
    /*
    * состояние выполняющее обработку пробела
    */
    int s_B1b();

    /*
    * состояние выполняющее поиск по регистру обнаружения регистром значение если 0 - ошибка
    */
    int s_B1a();

    /*
    * состояние выполняющее обработку '*'
    */
    int s_B1();

    /*
    * состояние выполняющее обработку '/'
    */
    int s_B1d();

    /*
    * состояние выполняющее ДА1Е
    */
    int s_B1e();

    /*
    * состояние выполняющее загрузку конца цикла в регистр класса
    */
    int s_C1a();

    /*
    * состояние выполняющее обработку табуляции
    */
    int s_C1();

    /*
    * состояние выполняющее создать лексему
    */
    int s_C2b();

    /*
    * состояние выполняющее обработку '-'
    */
    int s_C2a();

    /*
    * состояние выполняющее загрузку  в регистр указателя БАТ + Регистр значения
    */
    int s_C2d();

    /*
    * состояние выполняющее переход
    */
    int s_C2();

    /*
    * состояние выполняющее создать лексему
    */
    int s_D1c();

    /*
    * состояние выполняющее обработку '-'
    */
    int s_D1a();

    /*
    * состояние выполняющее Ригистр числа*10 Регистр числа + регистр значения
    */
    int s_D1b();

    /*
    * состояние выполняющее переход
    */
    int s_D1();

    /*
    * состояние выполняющее обработку закрывающей скобки
    */
    int s_D2a();

    /*
    * состояние выполняющее переход
    */
    int s_D2();

    /*
    * состояние выполняющее Регистр счетчика = 1 регистр значение -> пенисип чисоа
    */
    int s_D2b();

    /*
    * состояние выполняющее обработку открывающей скобки
    */
    int s_D2c();

    /*
    * состояние выполняющее регистр счетчика =0
    */
    int s_D3a();

    /*
    * состояние выполняющее переход
    */
    int s_D3();

    /*
    * состояние выполняющее если + - загрузи +1 если РЗ= 2 то -1 иначе ошибка
    */
    int s_D4a();

    /*
    * состояние выполняющее переход
    */
    int s_D4();

    /*
    * состояние выполняющее загрузку +1 в регистр знака
    */
    int s_D5a();

    /*
    * состояние выполняющее число регистр значения -> регист порядка
    */
    int s_D5b();

    /*
    * состояние выполняющее переход
    */
    int s_D5();

    /*
    * состояние выполняющее регистр порядка *10 регистр порядка + регистр значения
    */
    int s_D5c();

    /*
    * состояние выполняющее создать лексему
    */
    int s_D6a();

    /*
    * состояние выполняющее загрузку операнда в регистр класса
    */
    int s_D6();

    /*
    * состояние выполняющее обработку '^'
    */
    int s_E1a();

    /*
    * состояние выполняющее переход
    */
    int s_E1();

    /*
    * состояние выполняющее загрузку ПЕРЕХОД НА ПОДПР в регистр класса
    */
    int s_E1b();

    /*
    * состояние выполняющее загрузку СТРОКУ в регистр класса
    */
    int s_E2a();

    /*
    * состояние выполняющее загрузку в регистр строки регистр значения
    */
    int s_E2b();

    /*
    * состояние выполняющее переход
    */
    int s_E2();

    /*
    * состояние выполняющее *10 регистр строки регистр строки + регистр значения
    */
    int s_E2c();

    /*
    * состояние выполняющее загрузку присвоить в регистр класса
    */
    int s_F1a();

    /*
    * состояние выполняющее переход
    */
    int s_F1();

    /*
    * состояние выполняющее объявление начала слова или проверку константы
    */
    int s_F1b();

    /*
    * состояние выполняющее загрузку в регистр указателя БАТИ+ регистр значения
    */
    int s_F2a();

    /*
    * состояние выполняющее обработку точки в константе
    */
    int s_F2();

    /*
    * состояние выполняющее Регистр значения +1 *26 регистр указателя +
    */
    int s_F3a();

    /*
    * состояние выполняющее переход
    */
    int s_F3();

    /*
    * состояние выполняющее загрузку комментарий в регистр класса и создать лексему
    */
    int s_G1a();

    /*
    * состояние выполняющее проверку константы
    */
    int s_G1();

    /*
    * состояние выполняющее ДА1Д
    */
    int s_H1c();

    /*
    * состояние выполняющее СОЗДАТЬ ЛЕКСЕМУ
    */
    int s_H1b();

    /*
    * состояние выполняющее регистр значения => регистр отношения отношение -> регистр класса
    */
    int s_H1a();

    /*
    * состояние выполняющее переход
    */
    int s_H1();

    /*
    * состояние выполняющее ДА2Д
    */
    int s_H1d();

    /*
    * состояние выполняющее ДА3Д
    */
    int s_H1e();

    /*
    * состояние выполняющее обработку ошибки в записи константы
    */
    int s_H1f();

    /*
    * состояние выполняющее сравнить регитср обнаружения и регистр значения  == -> переход на регистр обнаруения если 0 то ошибка
    */
    int s_M1();

    /*
    * состояние выполняющее объявление начала константы
    */
    int s_M2();

    /*
    * состояние выполняющее РЗ - содержит чилсо не равное 5 то Да2Д и перезод на б1б если 5 то Д3
    */
    int s_M3();

    /*
    * состояние выполняющее Да1Д
    */
    int Exit3();

    /*
    * состояние выполняющее создать лексему
    */
    int Exit2();

    /*
    * состояние выполняющее загрузку Конц маркер в регистр класса создать лексему и выйти и ЛБ
    */
    int Exit1();

    /*
    * состояние выполняющее Да2Д и ВЫХОД2
    */
    int Exit4();

    /*
    * состояние выполняющее ДА3Д и ВЫХОД2
    */
    int Exit5();

    /*
    * состояние выполняющее ДА1Е и ВЫХОД2
    */
    int Exit6();

    /*
    * состояние выполняющее обработку ошибки
    */
    int Error();

    /*
    * состояние выполняющее загрузку возврат в регистр класса
    */
    int s_DA1D();

    /*
    * состояние выполняющее загрузку возврат в регистр класса
    */
    int s_DA2D();

    /*
    * состояние выполняющее загрузку возврат в регистр класса
    */
    int s_DA3D();

    /*
    * состояние выполняющее загрузку возврат в регистр класса
    */
    int s_DA1E();

    /*
    * состояние выполняющее загрузку возврат в регистр класса
    */
    int s_DA1ETSICL();

    //state_number = 19 -  число состояний без s_Stop
    //class_number = 11 - число символов входного алфавита

    int m_ch = 0;                                       // для проверок
    int m_line = 0;                                     // номер строки
    int m_i = 0;                                        // позиция в строке

    typedef int(LexicalBlock::* function_pointer)();
    function_pointer m_table[19][11];                   // таблица автомата

    std::string m_buffer;                               // буффер
    std::string m_lexem;                                // лексема
    std::string m_copy;                                 // копия лексемы

    bool m_mark = true;                                 // флаг метки
    bool m_constant = false;                            // флаг константы
    bool m_word = false;                                // флаг слова
    bool m_skip_point = false;                          // флаг пропуска
    bool m_is_rem = false;                              // флаг комментария
};
